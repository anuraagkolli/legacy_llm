{
  "base_model": "Qwen/Qwen2.5-Coder-1.5B-Instruct",
  "base_results": [
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01  Z            PIC 99.\n       01  XMAIN        PIC X(8).\n       01  XMAINRED REDEFINES XMAIN.\n           03  FILLER         PIC X(4).\n           03  XMAIN03.\n               05  XMAIN0501  PIC X(4).\n               05  XMAIN0502 REDEFINES XMAIN0501 PIC X(5).\n       01 USE-VARS.\n          05 USE-VALUE                PIC 9\n                                      VALUE ZERO.\n             88 USE-ACTIVE-FIRST      VALUE 1.\n             88 USE-ACTIVE-SECOND     VALUE 2.\n          05 USE-FIRST.\n             10 FIRST-DATA.\n                20 FIRST-DATA-VAR     PIC X(033).\n             10 FIRST-VARIANT-A REDEFINES FIRST-DATA.\n                20 PART-A-FIRST       PIC X(33211).\n             10 FIRST-VARIANT-B REDEFINES FIRST-DATA.\n                20 PART-B-FIRST       PIC X(24561).\n             10 FIRST-VARIANT-C REDEFINES FIRST-DATA.\n                20 PART-C-FIRST       PIC X(3421).\n         05 USE-SECOND REDEFINES USE-FIRST.\n            10 SECOND-HEADER.\n               20 SECOND-DATA         PIC 9(015).\n               20 SECOND-CONTROL-SUM  PIC 9(015)V9(003).\n            10 SECOND-VARIANT-A REDEFINES SECOND-HEADER.\n               20 PART-A-SECOND       PIC X(27241).\n            10 SECOND-VARIANT-B REDEFINES SECOND-HEADER.\n               20 PART-B-SECOND       PIC X(3879).\n       PROCEDURE        DIVISION.\n           MOVE    LENGTH OF XMAIN       TO Z.\n           IF Z NOT = 8\n              DISPLAY \"Test 1 \" Z.\n           MOVE    LENGTH OF XMAINRED    TO Z.\n           IF Z NOT = 9\n              DISPLAY \"Test 2 \" Z.\n           MOVE    LENGTH OF XMAIN03     TO Z.\n           IF Z NOT = 5\n              DISPLAY \"Test 3 \" Z.\n           MOVE    LENGTH OF XMAIN0501   TO Z.\n           IF Z NOT = 4\n              DISPLAY \"Test 4 \" Z.\n           MOVE    LENGTH OF XMAIN0502   TO Z.\n           IF Z NOT = 5\n              DISPLAY \"Test 5 \" Z.\n           IF LENGTH OF USE-FIRST  NOT = 33211\n              DISPLAY LENGTH OF USE-FIRST   END-DISPLAY.\n           IF LENGTH OF USE-SECOND NOT = 27241\n              DISPLAY LENGTH OF USE-SECOND  END-DISPLAY.\n           STOP RUN.\n",
      "reference": "def cobol_program():\n    \"\"\"Basic COBOL program structure equivalent\"\"\"\n\n    # WORKING-STORAGE SECTION\n    ws_counter = 0\n    ws_total = 0\n    ws_status = '00'\n    ws_eof = False\n\n    # PROCEDURE DIVISION\n\n    # Initialization\n    ws_counter = 0\n    ws_total = 0\n\n    # Main processing loop\n    while not ws_eof:\n        # Read/process data\n        ws_counter += 1\n        ws_total += ws_counter\n\n        # Check termination condition\n        if ws_counter >= 10:\n            ws_eof = True\n\n    # Termination\n    print(f\"Records processed: {ws_counter}\")\n    print(f\"Total: {ws_total}\")\n    print(f\"Status: {ws_status}\")\n\n    return ws_status\n\nif __name__ == '__main__':\n    result = cobol_program()\n    print(f\"Program ended with status: {result}\")",
      "output": "class Program:\n    def __init__(self):\n        self.z = 0\n        self.xmain = \"\"\n        self.xmain_red = \"\"\n        self.use_vars = {\n            'use_value': 0,\n            'use_active_first': True,\n            'use_active_second': False,\n            'use_first': {'first_data': '', 'first_variant_a': '', 'first_variant_b': '', 'first_variant_c': ''},\n            'use_second': {'second_header': '', 'second_control_sum': '', 'second_variant_a': '', 'second_variant_b': ''}\n        }\n\n    def test_length(self, variable_name):\n        length = len(variable_name)\n        if length != 0:\n            print(f\"Test {length} {variable_name}\")\n\n    def stop_run(self):\n        print(\"STOP RUN\")\n\ndef main():\n    program = Program()\n\n    program.test_length(program.xmain)\n    program.test_length(program.xmain_red)\n    program.test_length(program.xmain03)\n    program.test_length(program.xmain0501)\n    program.test_length(program.xmain0502)\n\n    program.stop_run()\n\nif __name__ == \"__main__\":\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.01716564775293231,
      "code_bleu": 0.049498877985085926
    },
    {
      "cobol": "IDENTIFICATION DIVISION.\n       PROGRAM-ID. prog.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n       SELECT file1 ASSIGN TO \"./file1X\"\n                    ORGANIZATION INDEXED\n                    ACCESS DYNAMIC RECORD KEY file1-key.\n       DATA DIVISION.\n       FILE SECTION.\n       FD file1.\n       1  file1-rec.\n          2  file1-key pic 999.\n          2  file1-data pic 999.\n       PROCEDURE DIVISION.\n          OPEN OUTPUT file1.\n          CLOSE file1.\n          OPEN I-O file1.\n          MOVE 10 TO file1-key file1-data.\n          WRITE file1-rec.\n          MOVE 11 TO file1-key file1-data.\n          WRITE file1-rec.\n          MOVE 12 TO file1-key file1-data.\n          WRITE file1-rec.\n          MOVE 13 TO file1-key file1-data.\n          WRITE file1-rec.\n      *\n          MOVE 0 TO file1-key.\n          START file1 KEY > file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 10)\n             DISPLAY \"FAILED: START key > 0\".\n      *\n          MOVE 99 TO file1-key.\n          START file1 KEY < file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 13)\n             DISPLAY \"FAILED: START key < 99\".\n      *\n          MOVE 999 TO file1-key.\n          START file1 FIRST.\n          READ file1 NEXT.\n          IF (file1-data <> 10)\n             DISPLAY \"FAILED: START key FIRST\".\n      *\n          MOVE 0 TO file1-key.\n          START file1 LAST.\n          READ file1 NEXT.\n          IF (file1-data <> 13)\n             DISPLAY \"FAILED: START key LAST\".\n      *\n          MOVE 0 TO file1-key.\n          START file1 KEY >= file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 10)\n             DISPLAY \"FAILED: START key >= 0\".\n      *\n          MOVE 99 TO file1-key.\n          START file1 KEY <= file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 13)\n             DISPLAY \"FAILED: START key <= 99\".\n\n          CLOSE file1.\n          STOP RUN.\n",
      "reference": "import shelve\nfrom dataclasses import dataclass\n\n@dataclass\nclass File1Record:\n    file1_key: int\n    file1_data: int\n\ndef main():\n    \"\"\"Indexed file with WRITE, START, and READ NEXT\"\"\"\n    filename = \"./file1X\"\n    \n    # OPEN OUTPUT file1, CLOSE file1\n    with shelve.open(filename, flag='c') as db:\n        pass  # Just create/close\n    \n    # OPEN I-O file1\n    with shelve.open(filename, flag='c') as db:\n        # Write records with keys 10, 11, 12, 13\n        for key_val in [10, 11, 12, 13]:\n            record = File1Record(file1_key=key_val, file1_data=key_val)\n            db[str(key_val).zfill(3)] = record  # PIC 999 format\n        \n        sorted_keys = sorted([int(k) for k in db.keys()])\n        \n        # START file1 KEY > file1-key (where file1-key = 0)\n        # Find first key > 0\n        keys_gt_0 = [k for k in sorted_keys if k > 0]\n        if keys_gt_0:\n            record = db[str(keys_gt_0[0]).zfill(3)]\n            if record.file1_data != 10:\n                print(\"FAILED: START key > 0\")\n        \n        # START file1 KEY < file1-key (where file1-key = 99)\n        keys_lt_99 = [k for k in sorted_keys if k < 99]\n        if keys_lt_99:\n            record = db[str(keys_lt_99[-1]).zfill(3)]\n            if record.file1_data != 13:\n                print(\"FAILED: START key < 99\")\n        \n        # START file1 FIRST\n        if sorted_keys:\n            record = db[str(sorted_keys[0]).zfill(3)]\n            if record.file1_data != 10:\n                print(\"FAILED: START key FIRST\")\n        \n        # START file1 LAST\n        if sorted_keys:\n            record = db[str(sorted_keys[-1]).zfill(3)]\n            if record.file1_data != 13:\n                print(\"FAILED: START key LAST\")\n        \n        # START file1 KEY >= file1-key (where file1-key = 0)\n        keys_gte_0 = [k for k in sorted_keys if k >= 0]\n        if keys_gte_0:\n            record = db[str(keys_gte_0[0]).zfill(3)]\n            if record.file1_data != 10:\n                print(\"FAILED: START key >= 0\")\n        \n        # START file1 KEY <= file1-key (where file1-key = 99)\n        keys_lte_99 = [k for k in sorted_keys if k <= 99]\n        if keys_lte_99:\n            record = db[str(keys_lte_99[-1]).zfill(3)]\n            if record.file1_data != 13:\n                print(\"FAILED: START key <= 99\")\n    \n    # CLOSE file1 (automatic with context manager)\n\nif __name__ == '__main__':\n    main()",
      "output": "import os\n\nclass File:\n    def __init__(self, filename):\n        self.filename = filename\n        self.file = None\n\n    def open(self):\n        if not os.path.exists(self.filename):\n            with open(self.filename, 'w') as f:\n                pass\n        self.file = open(self.filename, 'a')\n\n    def close(self):\n        if self.file:\n            self.file.close()\n\n    def write(self, record):\n        self.file.write(record + '\\n')\n\n    def read_next(self):\n        if self.file:\n            return self.file.readline().strip()\n        else:\n            return None\n\ndef main():\n    file1 = File('./file1X')\n    file1.open()\n\n    # Write initial records\n    for i in range(10, 14):\n        file1.write(f\"{i} {i}\")\n\n    # Start key tests\n    start_key_tests(file1)\n\n    # Close the file\n    file1.close()\n\ndef start_key_tests(file1):\n    keys = [0, 99, 999]\n    expected_data = [10, 13, 10]\n\n    for key, expected in zip(keys, expected_data):\n        file1.seek(0)  # Reset file pointer to the beginning\n        file1.write(f\"{key} {expected}\\n\")\n        file1.seek(0)  # Reset file pointer to the beginning\n        next_record = file1.read_next()\n        if next_record != f\"{key} {expected}\":\n            print(f\"Failed: START key {key}\")\n            break\n\nif __name__ == \"__main__\":\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.005372391152827286,
      "code_bleu": 0.05244630350171124
    },
    {
      "cobol": "$SET NOBOUND\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. progn.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  x VALUE \"12345!\".\n           03  y PIC X OCCURS 5 TIMES.\n           03  z PIC X.\n       01  idx PIC 99 VALUE 6.\n\n       PROCEDURE DIVISION.\n           DISPLAY y (idx) WITH NO ADVANCING\n           .\n",
      "reference": "def main():\n    \"\"\"COBOL program translation\"\"\"\n    # Working storage variables\n    idx = 6\n\n    # Program logic\n    print(y (idx), end='')\n\nif __name__ == '__main__':\n    main()",
      "output": "class Program:\n    def __init__(self):\n        self.x = \"12345!\"\n        self.y = [None] * 5\n        self.z = None\n        self.idx = 6\n\n    def display_y(self):\n        print(self.y[self.idx], end=\"\")\n\nif __name__ == \"__main__\":\n    prog = Program()\n    prog.display_y()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.0406731552331291,
      "code_bleu": 0.10864430452249815
    },
    {
      "cobol": "ID DIVISION.\n        PROGRAM-ID. ALLOC.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        77  X   PIC  9(2) PACKED-DECIMAL.\n        77  NUM-ELEMENTS PIC 9(4) BINARY.\n        77  SIZE-NEEDED  PIC 9(4) BINARY.\n        77  old-size     pic 9(4) binary.\n        77  VPTR  POINTER.\n\n        LINKAGE       SECTION.\n\n        01  VARGRP.\n          02  OBJ     PIC 9(4) COMP.\n          02  TABGRP.\n            03  VARTAB OCCURS 1 TO UNBOUNDED DEPENDING ON OBJ.\n              04  T1      PIC 9(4).\n              04  T2      PIC X(8).\n              04  T3      PIC 9(4). *> changed from COMP because of output\n        01 BUFFER         PIC X(1000).\n\n       PROCEDURE DIVISION.\n\n      *>    DISPLAY 'Starting testcase ALLOC'\n\n           SET VPTR To NULL\n\n      *************************************************************\n      *  Allocate a table with 20 elements\n      *************************************************************\n           COMPUTE NUM-ELEMENTS = 20\n           PERFORM ALLOC-VARGRP\n\n      *************************************************************\n      *  Set some 'test' values to validate re-allocated table\n      *************************************************************\n           initialize vartab(12), vartab(17)\n           COMPUTE T1(12) = 9999\n           MOVE 'HI MOM' TO T2 (17)\n      *>   DISPLAY '  '\n           DISPLAY 'VARTAB(12) = \"' VARTAB(12) '\"'\n           DISPLAY 'VARTAB(17) = \"' VARTAB(17) '\"'\n      *>   DISPLAY '  '\n\n      *************************************************************\n      *  Need a bigger table! Allocate a larger one and copy data\n      *************************************************************\n           COMPUTE NUM-ELEMENTS = 30\n           PERFORM ALLOC-VARGRP\n\n      *************************************************************\n      *  Ensure that new table has correct data from original\n      *************************************************************\n           DISPLAY 'VARTAB(12) = \"' VARTAB(12) '\"'\n           DISPLAY 'VARTAB(17) = \"' VARTAB(17) '\"'\n\n           GOBACK.\n\n      *************************************************************\n      *  The first time allocate the original table.  If the table\n      *  has already been allocated, assume that we are allocating\n      *  a larger one and want to copy the data over to it\n      *************************************************************\n        ALLOC-VARGRP.\n\n           If VPTR = NULL Then      *> If first time, allocate the table\n             COMPUTE SIZE-NEEDED = LENGTH OF OBJ +\n                                 LENGTH OF VARTAB * NUM-ELEMENTS\n             display 'First allocation, using ' size-needed ' bytes.'\n             ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR\n\n             SET ADDRESS OF VARGRP TO VPTR\n             MOVE NUM-ELEMENTS TO OBJ\n             move SIZE-NEEDED  to old-size\n\n           Else                     *> If already have a table, doing re-size\n      *********************************************************************\n      * Re-size it!\n      * First, map BUFFER on current table\n      *********************************************************************\n\n             SET ADDRESS OF BUFFER TO VPTR\n\n      *********************************************************************\n      * Calculate new size from NUM-ElEMENTS\n      *********************************************************************\n             COMPUTE SIZE-NEEDED = LENGTH OF OBJ +\n                                   LENGTH OF VARTAB * NUM-ELEMENTS\n\n             display 'Re-allocation, using ' size-needed ' bytes.'\n      *>     ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR\n             if size-needed < 2097152\n                ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED\n                                                loc 24\n                                                RETURNING VPTR\n             else\n                ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED\n                                                loc 31\n                                                RETURNING VPTR\n             end-if\n\n      *************************************************************\n      * Move data from data save area to new larger table\n      *************************************************************\n             SET ADDRESS OF VARGRP TO VPTR\n             MOVE NUM-ELEMENTS TO OBJ\n             MOVE BUFFER(1:old-size) TO VARGRP\n             move SIZE-NEEDED  to old-size\n      *************************************************************\n      * Free the original table\n      ************************************************************\n             SET VPTR TO ADDRESS OF BUFFER\n             FREE VPTR\n             .\n",
      "reference": "from decimal import Decimal, ROUND_HALF_UP\nimport math\n\ndef compute_examples():\n    \"\"\"COBOL COMPUTE statement equivalents with proper decimal handling\"\"\"\n\n    # Basic arithmetic with COBOL-style rounding\n    def compute(expression, decimals=2):\n        \"\"\"COMPUTE equivalent with ROUNDED\"\"\"\n        result = Decimal(str(expression))\n        if decimals >= 0:\n            quantize_str = '0.' + '0' * decimals if decimals > 0 else '0'\n            result = result.quantize(Decimal(quantize_str), rounding=ROUND_HALF_UP)\n        return result\n\n    # COMPUTE with multiple operations\n    a = Decimal('100.00')\n    b = Decimal('3')\n    c = Decimal('2.5')\n\n    # COMPUTE result = a / b\n    result1 = compute(a / b, 2)\n    print(f\"100 / 3 ROUNDED: {result1}\")\n\n    # COMPUTE result = a * b + c\n    result2 = compute(a * b + c, 2)\n    print(f\"100 * 3 + 2.5: {result2}\")\n\n    # COMPUTE with exponentiation (** in COBOL)\n    result3 = compute(Decimal('2') ** Decimal('10'), 0)\n    print(f\"2 ** 10: {result3}\")\n\n    # COMPUTE percentage\n    total = Decimal('1500.00')\n    part = Decimal('375.00')\n    pct = compute((part / total) * 100, 2)\n    print(f\"Percentage: {pct}%\")\n\n    # ON SIZE ERROR handling\n    def compute_with_size_check(expression, max_digits=9, decimals=2):\n        \"\"\"COMPUTE with ON SIZE ERROR equivalent\"\"\"\n        try:\n            result = compute(expression, decimals)\n            # Check if result exceeds max size\n            int_part = abs(int(result))\n            if len(str(int_part)) > max_digits:\n                raise OverflowError(\"Size error\")\n            return result, False  # result, size_error\n        except (OverflowError, ZeroDivisionError):\n            return Decimal('0'), True  # result, size_error\n\n    result, error = compute_with_size_check(Decimal('999999999') * 10, max_digits=9)\n    print(f\"Size error test: result={result}, error={error}\")\n\n    # Division with remainder\n    dividend = Decimal('17')\n    divisor = Decimal('5')\n    quotient = int(dividend // divisor)\n    remainder = dividend % divisor\n    print(f\"17 / 5: quotient={quotient}, remainder={remainder}\")\n\nif __name__ == '__main__':\n    compute_examples()",
      "output": "import ctypes\n\nclass VarGroup(ctypes.Structure):\n    _fields_ = [\n        (\"OBJ\", ctypes.c_int),\n        (\"TABGRP\", ctypes.POINTER(\"VarTab\"))\n    ]\n\nclass VarTab(ctypes.Structure):\n    _fields_ = [\n        (\"T1\", ctypes.c_int),\n        (\"T2\", ctypes.c_char * 8),\n        (\"T3\", ctypes.c_int)\n    ]\n\ndef allocate_table(obj_size, num_elements):\n    buffer = ctypes.create_string_buffer(obj_size * num_elements)\n    return buffer\n\ndef main():\n    # Initialize variables\n    x = 0\n    num_elements = 20\n    size_needed = 0\n    old_size = 0\n    vptr = None\n\n    # Allocate a table with 20 elements\n    buffer = allocate_table(num_elements * 4, num_elements)\n\n    # Set some 'test' values to validate re-allocated table\n    vartab = (VarTab * num_elements)(*(VarTab * num_elements)(\n        VarTab(T1=9999, T2=b\"HI MOM\", T3=0),\n        VarTab(T1=9999, T2=b\"HI MOM\", T3=0)\n    ))\n    address_of_vargrp = ctypes.addressof(vartab[0])\n\n    # Need a bigger table! Allocate a larger one and copy data\n    num_elements = 30\n    buffer = allocate_table(num_elements * 4, num_elements)\n\n    # Ensure that new table has correct data from original\n    print(f\"VARTAB(12) = {vartab[12].T1}\")\n    print(f\"VARTAB(17) = {vartab[17].T2.decode('utf-8')}\")\n\n    # Go back\n    return\n\nif __name__ == \"__main__\":\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.00602673636985067,
      "code_bleu": 0.042544730264709396
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01  TEST-FLD     PIC S9(09)V9(02).\n       PROCEDURE        DIVISION.\n           MOVE FUNCTION INTEGER-OF-DAY ( 2000269 )\n             TO TEST-FLD.\n           IF TEST-FLD NOT = 000146000\n              DISPLAY TEST-FLD\n              END-DISPLAY\n           END-IF.\n           STOP RUN.\n",
      "reference": "def cobol_functions_example():\n    \"\"\"Demonstrates COBOL intrinsic function equivalents\"\"\"\n    import math\n    from datetime import datetime, date\n\n    # Numeric functions\n    value = -42.7\n    abs_val = abs(value)                    # FUNCTION ABS\n    integer_val = int(value)                # FUNCTION INTEGER\n    integer_part = int(abs(value))          # FUNCTION INTEGER-PART\n\n    # Math functions\n    x = 2.5\n    sqrt_val = math.sqrt(x)                 # FUNCTION SQRT\n    log_val = math.log(x)                   # FUNCTION LOG\n    log10_val = math.log10(x)               # FUNCTION LOG10\n    exp_val = math.exp(x)                   # FUNCTION EXP\n\n    # Trigonometric\n    angle = 0.5\n    sin_val = math.sin(angle)               # FUNCTION SIN\n    cos_val = math.cos(angle)               # FUNCTION COS\n    tan_val = math.tan(angle)               # FUNCTION TAN\n    asin_val = math.asin(angle)             # FUNCTION ASIN\n\n    # String functions\n    text = \"  Hello World  \"\n    trimmed = text.strip()                  # FUNCTION TRIM\n    upper = text.upper()                    # FUNCTION UPPER-CASE\n    lower = text.lower()                    # FUNCTION LOWER-CASE\n    reversed_text = text[::-1]              # FUNCTION REVERSE\n    length = len(text)                      # FUNCTION LENGTH\n\n    # Date/Time functions\n    now = datetime.now()\n    current_date = now.strftime(\"%Y%m%d\")   # FUNCTION CURRENT-DATE\n    day_of_week = now.isoweekday()          # FUNCTION DAY-OF-WEEK (1=Mon)\n\n    # Statistical functions\n    numbers = [10, 20, 30, 40, 50]\n    max_val = max(numbers)                  # FUNCTION MAX\n    min_val = min(numbers)                  # FUNCTION MIN\n    sum_val = sum(numbers)                  # FUNCTION SUM\n    mean_val = sum(numbers) / len(numbers)  # FUNCTION MEAN\n\n    # ORD and CHAR\n    char_code = ord('A')                    # FUNCTION ORD\n    char_val = chr(65)                      # FUNCTION CHAR\n\n    return {\n        'abs': abs_val,\n        'sqrt': sqrt_val,\n        'trim': trimmed,\n        'upper': upper,\n        'max': max_val,\n        'mean': mean_val\n    }\n\nif __name__ == '__main__':\n    result = cobol_functions_example()\n    for k, v in result.items():\n        print(f\"{k}: {v}\")",
      "output": "from datetime import date\n\ndef main():\n    test_field = int(date.fromisoformat(\"2000-02-26\").strftime(\"%j\"))\n    \n    if test_field != 14600:\n        print(test_field)\n\nif __name__ == \"__main__\":\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 1.0282157124677816e-06,
      "code_bleu": 0.00021305255015516443
    },
    {
      "cobol": "CONTROL\t\tDIVISION.\n       DEFAULT\t\tSECTION.\n       IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01 VAR PIC X(2) VALUE \"OK\".\n       PROCEDURE        DIVISION.\n           DISPLAY VAR NO ADVANCING\n           END-DISPLAY.\n           STOP RUN.\n",
      "reference": "def main():\n    print(VAR, end='')\n\nif __name__ == '__main__':\n    main()",
      "output": "class Program:\n    def __init__(self):\n        self.var = 'OK'\n\n    def display(self):\n        print(self.var)\n\nif __name__ == '__main__':\n    p = Program()\n    p.display()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.14216645907653844,
      "code_bleu": 0.26224009924510383
    },
    {
      "cobol": "IDENTIFICATION       DIVISION.\n       PROGRAM-ID.          prog.\n\n       DATA                 DIVISION.\n       WORKING-STORAGE      SECTION.\n       01  a.\n           03  b            PIC X(3) VALUE SPACES.\n           03  c            PIC X(3) VALUE SPACES.\n\n       01  p.\n           03  q            PIC 9(3) VALUE ZERO.\n           03  r            PIC X(3) VALUE \"abc\".\n\n       01  x.\n           03  y.\n               05  z        PIC X VALUE SPACE.\n\n       01  out              PIC X(100).\n\n       PROCEDURE            DIVISION.\n           XML GENERATE out FROM a SUPPRESS WHEN SPACES\n           IF out <> '<a/>'\n               DISPLAY 'Test 1 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM a SUPPRESS b WHEN SPACES\n           IF out <> '<a><c> </c></a>'\n               DISPLAY 'Test 2 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM a SUPPRESS EVERY NONNUMERIC WHEN SPACES\n           IF out <> '<a/>'\n               DISPLAY 'Test 3 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM p\n               WITH ATTRIBUTES\n               SUPPRESS EVERY ATTRIBUTE WHEN ZERO\n           IF out <> '<p r=\"abc\"/>'\n               DISPLAY 'Test 4 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM a\n               SUPPRESS c WHEN LOW-VALUES, c WHEN SPACES,\n                    c WHEN LOW-VALUES,\n                    EVERY ELEMENT WHEN SPACES\n           IF out <> '<a><c> </c></a>'\n               DISPLAY 'Test 5 failed: ' out\n           END-IF\n\n           MOVE HIGH-VALUES TO b\n           MOVE LOW-VALUES TO c\n           XML GENERATE out FROM a\n               SUPPRESS EVERY ELEMENT WHEN HIGH-VALUES OR LOW-VALUES\n                   OR ZEROES OR SPACES\n           IF out <> '<a/>'\n               DISPLAY 'Test 6 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM x SUPPRESS z WHEN SPACE\n           IF out <> '<x/>'\n               DISPLAY 'Test 7 failed: ' out\n           END-IF\n           .\n",
      "reference": "class ReportWriter:\n    \"\"\"COBOL Report Writer (RD) equivalent\"\"\"\n\n    def __init__(self, filename, page_limit=60, heading_lines=3):\n        self.filename = filename\n        self.page_limit = page_limit\n        self.heading_lines = heading_lines\n        self.line_counter = 0\n        self.page_counter = 0\n        self.file = None\n        self.controls = {}\n        self.totals = {}\n\n    def initiate(self):\n        \"\"\"INITIATE report-name\"\"\"\n        self.file = open(self.filename, 'w')\n        self.line_counter = 0\n        self.page_counter = 0\n        self.totals = {}\n\n    def terminate(self):\n        \"\"\"TERMINATE report-name\"\"\"\n        self._write_final_totals()\n        self.file.close()\n\n    def generate(self, line_type, data=None, control_field=None):\n        \"\"\"GENERATE detail-line or summary-line\"\"\"\n\n        # Check for control break\n        if control_field:\n            if control_field in self.controls:\n                if self.controls[control_field] != data.get(control_field):\n                    self._write_control_footing(control_field)\n                    self._write_control_heading(control_field, data)\n            else:\n                self._write_control_heading(control_field, data)\n            self.controls[control_field] = data.get(control_field)\n\n        # Check for page break\n        if self.line_counter >= self.page_limit:\n            self._new_page()\n\n        # Write the line\n        if line_type == 'DETAIL':\n            self._write_detail(data)\n        elif line_type == 'HEADING':\n            self._write_heading(data)\n\n        self.line_counter += 1\n\n    def _new_page(self):\n        self.page_counter += 1\n        self.file.write('\\f')  # Form feed\n        self.line_counter = 0\n        self._write_page_heading()\n\n    def _write_page_heading(self):\n        self.file.write(f\"{'=' * 70}\\n\")\n        self.file.write(f\"Page {self.page_counter:4d}\\n\")\n        self.file.write(f\"{'=' * 70}\\n\")\n        self.line_counter += self.heading_lines\n\n    def _write_heading(self, data):\n        self.file.write(f\"{data.get('title', 'REPORT')}\\n\")\n\n    def _write_detail(self, data):\n        line = ' | '.join(str(v) for v in data.values())\n        self.file.write(f\"{line}\\n\")\n\n        # Accumulate totals\n        for key, value in data.items():\n            if isinstance(value, (int, float)):\n                self.totals[key] = self.totals.get(key, 0) + value\n\n    def _write_control_heading(self, field, data):\n        self.file.write(f\"\\n--- {field}: {data.get(field)} ---\\n\")\n\n    def _write_control_footing(self, field):\n        self.file.write(f\"--- End of {field} ---\\n\\n\")\n\n    def _write_final_totals(self):\n        self.file.write(\"\\n\" + \"=\" * 40 + \"\\n\")\n        self.file.write(\"FINAL TOTALS:\\n\")\n        for key, value in self.totals.items():\n            self.file.write(f\"  {key}: {value}\\n\")\n\n# Example usage\nif __name__ == '__main__':\n    report = ReportWriter('sales_report.txt', page_limit=20)\n    report.initiate()\n\n    # Sample data\n    sales_data = [\n        {'region': 'EAST', 'product': 'Widget', 'amount': 1500},\n        {'region': 'EAST', 'product': 'Gadget', 'amount': 2300},\n        {'region': 'WEST', 'product': 'Widget', 'amount': 1800},\n        {'region': 'WEST', 'product': 'Gadget', 'amount': 2100},\n    ]\n\n    for record in sales_data:\n        report.generate('DETAIL', record, control_field='region')\n\n    report.terminate()\n    print(\"Report generated: sales_report.txt\")",
      "output": "import xml.etree.ElementTree as ET\n\ndef generate_xml(element, attributes=None):\n    if attributes:\n        element.set(**attributes)\n    return ET.tostring(element, encoding='unicode')\n\ndef test_xml_generation():\n    # Test 1\n    root = ET.Element('a')\n    result = generate_xml(root)\n    assert result == '<a/>', f\"Test 1 failed: {result}\"\n\n    # Test 2\n    root = ET.Element('a')\n    root.append(ET.SubElement(root, 'c'))\n    result = generate_xml(root)\n    assert result == '<a><c> </c></a>', f\"Test 2 failed: {result}\"\n\n    # Test 3\n    root = ET.Element('a')\n    result = generate_xml(root)\n    assert result == '<a/>', f\"Test 3 failed: {result}\"\n\n    # Test 4\n    root = ET.Element('p')\n    root.attrib['r'] = 'abc'\n    result = generate_xml(root)\n    assert result == '<p r=\"abc\"/>', f\"Test 4 failed: {result}\"\n\n    # Test 5\n    root = ET.Element('a')\n    root.append(ET.SubElement(root, 'c'))\n    result = generate_xml(root)\n    assert result == '<a><c> </c></a>', f\"Test 5 failed: {result}\"\n\n    # Test 6\n    root = ET.Element('a')\n    root.append(ET.SubElement(root, 'c'))\n    root.append(ET.SubElement(root, 'd'))\n    result = generate_xml(root)\n    assert result == '<a/>', f\"Test 6 failed: {result}\"\n\n    # Test 7\n    root = ET.Element('x')\n    root.append(ET.SubElement(root, 'z'))\n    result = generate_xml(root)\n    assert result == '<x/>', f\"Test 7 failed: {result}\"\n\ntest_xml_generation()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.0012658804738173229,
      "code_bleu": 0.015301758798425715
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE SECTION.\n       77  window-handle USAGE HANDLE OF WINDOW.\n       77  lb-row        PIC X(10).\n       77  lb-color      PIC 9(05) VALUE 8192.\n       77  lb-num-lines  PIC 9(02) VALUE 20.\n       77  lb-num-rows   PIC 9(02) VALUE 11.\n       77  window-lines  PIC 9(02) VALUE 22.\n       77  window-rows   PIC 9(02) VALUE 13.\n       77  selection-idx PIC S9(02).\n       SCREEN SECTION.\n       01 lb-screen.\n           03 lb-frm LIST-BOX 3-D\n      *             FIXME: the following should be possible in any order\n                    UNSORTED\n                    EXCEPTION-VALUE = 13\n                    COLOR lb-color\n                    CLINE 1 CCOL 1\n                    LINES = lb-num-lines\n                    SIZE  IS lb-num-rows\n      *             VALUE lb-row  raises error as no identifer according\n      *                           to cobol2002, but here it is fine\n                    .\n       PROCEDURE DIVISION.\n       MAIN.\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 1'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 2'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 3'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 4'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 5'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 6'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 7'\n           DISPLAY FLOATING WINDOW\n               LINE 5 COL 5\n               LINES window-lines\n               SIZE  window-rows\n               BOXED\n               COLOR lb-color\n               HANDLE IS window-handle\n           END-DISPLAY\n           DISPLAY lb-screen\n           ACCEPT  lb-screen\n           IF lb-row = SPACES\n              INQUIRE lb-frm SELECTION-INDEX IN selection-idx\n              IF selection-idx > ZERO\n                 MODIFY  lb-frm QUERY-INDEX = selection-idx\n                 INQUIRE lb-frm ITEM-VALUE IN lb-row\n              END-IF\n           END-IF\n           CLOSE WINDOW window-handle\n           DISPLAY \"chosen row value was '\" lb-row \"'\"\n           ACCEPT OMITTED\n      *\n           STOP RUN.\n",
      "reference": "def main():\n    \"\"\"COBOL program translation for prog (GnuCOBOL #326)\"\"\"\n    # This COBOL program has complex features\n    # Original COBOL performs: output display, conditional logic, screen/GUI handling\n    print(\"COBOL program executed\")\n\nif __name__ == '__main__':\n    main()",
      "output": "from tkinter import Tk, Listbox, messagebox\n\nclass ListBox:\n    def __init__(self, master):\n        self.master = master\n        self.master.title(\"ListBox Example\")\n        self.listbox = Listbox(master)\n        self.listbox.pack(pady=20)\n\n    def add_items(self, items):\n        for item in items:\n            self.listbox.insert('end', item)\n\ndef main():\n    root = Tk()\n    listbox = ListBox(root)\n\n    # Add items to the listbox\n    listbox.add_items(['Row 1', 'Row 2', 'Row 3', 'Row 4', 'Row 5', 'Row 6', 'Row 7'])\n\n    # Display the listbox\n    listbox.pack(pady=20)\n\n    # Display the listbox content\n    print(listbox.get(0, 'end'))\n\n    # Accept user input from the listbox\n    selected_item = listbox.get(listbox.curselection())\n    print(f\"Chosen row value was '{selected_item}'\")\n\n    # Close the window\n    root.destroy()\n\nif __name__ == \"__main__\":\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.013858969391056856,
      "code_bleu": 0.05294097366236829
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       PROCEDURE        DIVISION.\n           DISPLAY \"OK\"-\n            \"OK\"\n             NO ADVANCING\n           END-DISPLAY\n           STOP RUN.\n",
      "reference": "def main():\n    print(\"OK\", \"OK\", end='')\n    print('')\n\nif __name__ == '__main__':\n    main()",
      "output": "class Program:\n    def __init__(self):\n        pass\n\n    def run(self):\n        print(\"OK OK\")\n        return None\n\nif __name__ == \"__main__\":\n    p = Program()\n    p.run()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.05415315253510895,
      "code_bleu": 0.21506185806073183
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01  X            PIC X(2) VALUE \"OK\".\n       PROCEDURE        DIVISION.\n           CALL \"C$TOLOWER\" USING X BY VALUE 2\n           END-CALL.\n           IF X NOT = \"ok\"\n              DISPLAY X NO ADVANCING\n              END-DISPLAY\n           END-IF.\n           STOP RUN.\n",
      "reference": "def main_program():\n    \"\"\"COBOL CALL statement equivalents\"\"\"\n\n    # Simple CALL\n    print(\"Calling subprogram...\")\n    result = subprogram_1(\"input_value\")\n    print(f\"Returned: {result}\")\n\n    # CALL with BY REFERENCE (modifiable)\n    data = {'value': 100, 'status': 'A'}\n    subprogram_by_reference(data)\n    print(f\"After BY REFERENCE call: {data}\")\n\n    # CALL with BY CONTENT (copy, not modifiable)\n    original = \"original\"\n    subprogram_by_content(original)\n    print(f\"After BY CONTENT call: {original}\")  # Unchanged\n\n    # CALL with BY VALUE\n    num = 42\n    result = subprogram_by_value(num)\n    print(f\"BY VALUE result: {result}\")\n\n    # CALL with RETURNING\n    return_value = subprogram_with_return()\n    print(f\"RETURNING value: {return_value}\")\n\n    # CALL with ON EXCEPTION (error handling)\n    try:\n        call_with_exception(\"nonexistent_program\")\n    except ModuleNotFoundError:\n        print(\"ON EXCEPTION: Program not found\")\n\n    # CANCEL - unload program (in Python, just del reference)\n    print(\"Program completed\")\n\ndef subprogram_1(param):\n    \"\"\"Basic subprogram\"\"\"\n    return f\"processed_{param}\"\n\ndef subprogram_by_reference(data_dict):\n    \"\"\"BY REFERENCE - modifies the passed data\"\"\"\n    data_dict['value'] += 50\n    data_dict['status'] = 'M'\n\ndef subprogram_by_content(data):\n    \"\"\"BY CONTENT - receives a copy\"\"\"\n    data = \"modified\"  # Only modifies local copy\n    return data\n\ndef subprogram_by_value(num):\n    \"\"\"BY VALUE - receives value\"\"\"\n    return num * 2\n\ndef subprogram_with_return():\n    \"\"\"RETURNING clause equivalent\"\"\"\n    return 999\n\ndef call_with_exception(prog_name):\n    \"\"\"ON EXCEPTION equivalent\"\"\"\n    # In real COBOL, this would try to load the program\n    raise ModuleNotFoundError(f\"Program {prog_name} not found\")\n\nif __name__ == '__main__':\n    main_program()",
      "output": "import ctypes\n\ndef c_to_lower(s):\n    return s.lower()\n\nclass Program:\n    def __init__(self):\n        self.x = 'OK'\n\n    def run(self):\n        x = self.x.encode('utf-8')\n        result = ctypes.c_char_p()\n        ctypes.CDLL(None).C$TOLOWER(ctypes.byref(result), x, len(x))\n        result_str = result.value.decode('utf-8')\n        if result_str != 'ok':\n            print(result_str)\n        return result_str\n\nif __name__ == '__main__':\n    p = Program()\n    p.run()",
      "valid_syntax": false,
      "syntax_error": "invalid syntax (<unknown>, line 13)",
      "bleu": 0.0024687390602586316,
      "code_bleu": 0.014897958961755615
    }
  ],
  "finetuned_results": [
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01  Z            PIC 99.\n       01  XMAIN        PIC X(8).\n       01  XMAINRED REDEFINES XMAIN.\n           03  FILLER         PIC X(4).\n           03  XMAIN03.\n               05  XMAIN0501  PIC X(4).\n               05  XMAIN0502 REDEFINES XMAIN0501 PIC X(5).\n       01 USE-VARS.\n          05 USE-VALUE                PIC 9\n                                      VALUE ZERO.\n             88 USE-ACTIVE-FIRST      VALUE 1.\n             88 USE-ACTIVE-SECOND     VALUE 2.\n          05 USE-FIRST.\n             10 FIRST-DATA.\n                20 FIRST-DATA-VAR     PIC X(033).\n             10 FIRST-VARIANT-A REDEFINES FIRST-DATA.\n                20 PART-A-FIRST       PIC X(33211).\n             10 FIRST-VARIANT-B REDEFINES FIRST-DATA.\n                20 PART-B-FIRST       PIC X(24561).\n             10 FIRST-VARIANT-C REDEFINES FIRST-DATA.\n                20 PART-C-FIRST       PIC X(3421).\n         05 USE-SECOND REDEFINES USE-FIRST.\n            10 SECOND-HEADER.\n               20 SECOND-DATA         PIC 9(015).\n               20 SECOND-CONTROL-SUM  PIC 9(015)V9(003).\n            10 SECOND-VARIANT-A REDEFINES SECOND-HEADER.\n               20 PART-A-SECOND       PIC X(27241).\n            10 SECOND-VARIANT-B REDEFINES SECOND-HEADER.\n               20 PART-B-SECOND       PIC X(3879).\n       PROCEDURE        DIVISION.\n           MOVE    LENGTH OF XMAIN       TO Z.\n           IF Z NOT = 8\n              DISPLAY \"Test 1 \" Z.\n           MOVE    LENGTH OF XMAINRED    TO Z.\n           IF Z NOT = 9\n              DISPLAY \"Test 2 \" Z.\n           MOVE    LENGTH OF XMAIN03     TO Z.\n           IF Z NOT = 5\n              DISPLAY \"Test 3 \" Z.\n           MOVE    LENGTH OF XMAIN0501   TO Z.\n           IF Z NOT = 4\n              DISPLAY \"Test 4 \" Z.\n           MOVE    LENGTH OF XMAIN0502   TO Z.\n           IF Z NOT = 5\n              DISPLAY \"Test 5 \" Z.\n           IF LENGTH OF USE-FIRST  NOT = 33211\n              DISPLAY LENGTH OF USE-FIRST   END-DISPLAY.\n           IF LENGTH OF USE-SECOND NOT = 27241\n              DISPLAY LENGTH OF USE-SECOND  END-DISPLAY.\n           STOP RUN.\n",
      "reference": "def cobol_program():\n    \"\"\"Basic COBOL program structure equivalent\"\"\"\n\n    # WORKING-STORAGE SECTION\n    ws_counter = 0\n    ws_total = 0\n    ws_status = '00'\n    ws_eof = False\n\n    # PROCEDURE DIVISION\n\n    # Initialization\n    ws_counter = 0\n    ws_total = 0\n\n    # Main processing loop\n    while not ws_eof:\n        # Read/process data\n        ws_counter += 1\n        ws_total += ws_counter\n\n        # Check termination condition\n        if ws_counter >= 10:\n            ws_eof = True\n\n    # Termination\n    print(f\"Records processed: {ws_counter}\")\n    print(f\"Total: {ws_total}\")\n    print(f\"Status: {ws_status}\")\n\n    return ws_status\n\nif __name__ == '__main__':\n    result = cobol_program()\n    print(f\"Program ended with status: {result}\")",
      "output": "def cobol_program():\n    \"\"\"Basic COBOL program structure equivalent\"\"\"\n\n    # WORKING-STORAGE SECTION\n    ws_counter = 0\n    ws_total = 0\n    ws_status = '00'\n    ws_eof = False\n\n    # PROCEDURE DIVISION\n\n    # Initialization\n    ws_counter = 0\n    ws_total = 0\n\n    # Main processing loop\n    while not ws_eof:\n        # Read/process data\n        ws_counter += 1\n        ws_total += ws_counter\n\n        # Check termination condition\n        if ws_counter >= 10:\n            ws_eof = True\n\n    # Termination\n    print(f\"Records processed: {ws_counter}\")\n    print(f\"Total: {ws_total}\")\n    print(f\"Status: {ws_status}\")\n\n    return ws_status\n\nif __name__ == '__main__':\n    result = cobol_program()\n    print(f\"Program ended with status: {result}\")",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 1.0,
      "code_bleu": 1.0
    },
    {
      "cobol": "IDENTIFICATION DIVISION.\n       PROGRAM-ID. prog.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n       SELECT file1 ASSIGN TO \"./file1X\"\n                    ORGANIZATION INDEXED\n                    ACCESS DYNAMIC RECORD KEY file1-key.\n       DATA DIVISION.\n       FILE SECTION.\n       FD file1.\n       1  file1-rec.\n          2  file1-key pic 999.\n          2  file1-data pic 999.\n       PROCEDURE DIVISION.\n          OPEN OUTPUT file1.\n          CLOSE file1.\n          OPEN I-O file1.\n          MOVE 10 TO file1-key file1-data.\n          WRITE file1-rec.\n          MOVE 11 TO file1-key file1-data.\n          WRITE file1-rec.\n          MOVE 12 TO file1-key file1-data.\n          WRITE file1-rec.\n          MOVE 13 TO file1-key file1-data.\n          WRITE file1-rec.\n      *\n          MOVE 0 TO file1-key.\n          START file1 KEY > file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 10)\n             DISPLAY \"FAILED: START key > 0\".\n      *\n          MOVE 99 TO file1-key.\n          START file1 KEY < file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 13)\n             DISPLAY \"FAILED: START key < 99\".\n      *\n          MOVE 999 TO file1-key.\n          START file1 FIRST.\n          READ file1 NEXT.\n          IF (file1-data <> 10)\n             DISPLAY \"FAILED: START key FIRST\".\n      *\n          MOVE 0 TO file1-key.\n          START file1 LAST.\n          READ file1 NEXT.\n          IF (file1-data <> 13)\n             DISPLAY \"FAILED: START key LAST\".\n      *\n          MOVE 0 TO file1-key.\n          START file1 KEY >= file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 10)\n             DISPLAY \"FAILED: START key >= 0\".\n      *\n          MOVE 99 TO file1-key.\n          START file1 KEY <= file1-key.\n          READ file1 NEXT.\n          IF (file1-data <> 13)\n             DISPLAY \"FAILED: START key <= 99\".\n\n          CLOSE file1.\n          STOP RUN.\n",
      "reference": "import shelve\nfrom dataclasses import dataclass\n\n@dataclass\nclass File1Record:\n    file1_key: int\n    file1_data: int\n\ndef main():\n    \"\"\"Indexed file with WRITE, START, and READ NEXT\"\"\"\n    filename = \"./file1X\"\n    \n    # OPEN OUTPUT file1, CLOSE file1\n    with shelve.open(filename, flag='c') as db:\n        pass  # Just create/close\n    \n    # OPEN I-O file1\n    with shelve.open(filename, flag='c') as db:\n        # Write records with keys 10, 11, 12, 13\n        for key_val in [10, 11, 12, 13]:\n            record = File1Record(file1_key=key_val, file1_data=key_val)\n            db[str(key_val).zfill(3)] = record  # PIC 999 format\n        \n        sorted_keys = sorted([int(k) for k in db.keys()])\n        \n        # START file1 KEY > file1-key (where file1-key = 0)\n        # Find first key > 0\n        keys_gt_0 = [k for k in sorted_keys if k > 0]\n        if keys_gt_0:\n            record = db[str(keys_gt_0[0]).zfill(3)]\n            if record.file1_data != 10:\n                print(\"FAILED: START key > 0\")\n        \n        # START file1 KEY < file1-key (where file1-key = 99)\n        keys_lt_99 = [k for k in sorted_keys if k < 99]\n        if keys_lt_99:\n            record = db[str(keys_lt_99[-1]).zfill(3)]\n            if record.file1_data != 13:\n                print(\"FAILED: START key < 99\")\n        \n        # START file1 FIRST\n        if sorted_keys:\n            record = db[str(sorted_keys[0]).zfill(3)]\n            if record.file1_data != 10:\n                print(\"FAILED: START key FIRST\")\n        \n        # START file1 LAST\n        if sorted_keys:\n            record = db[str(sorted_keys[-1]).zfill(3)]\n            if record.file1_data != 13:\n                print(\"FAILED: START key LAST\")\n        \n        # START file1 KEY >= file1-key (where file1-key = 0)\n        keys_gte_0 = [k for k in sorted_keys if k >= 0]\n        if keys_gte_0:\n            record = db[str(keys_gte_0[0]).zfill(3)]\n            if record.file1_data != 10:\n                print(\"FAILED: START key >= 0\")\n        \n        # START file1 KEY <= file1-key (where file1-key = 99)\n        keys_lte_99 = [k for k in sorted_keys if k <= 99]\n        if keys_lte_99:\n            record = db[str(keys_lte_99[-1]).zfill(3)]\n            if record.file1_data != 13:\n                print(\"FAILED: START key <= 99\")\n    \n    # CLOSE file1 (automatic with context manager)\n\nif __name__ == '__main__':\n    main()",
      "output": "import shelve\n\ndef read_indexed_file(filename):\n    \"\"\"Read records from indexed file (like COBOL indexed file)\"\"\"\n    record_count = 0\n    \n    try:\n        with shelve.open(filename, flag='r') as db:\n            for key in sorted(db.keys()):\n                record = db[key]\n                print(f'Record {record_count}: {record}')\n                record_count += 1\n    except FileNotFoundError:\n        print(f'Error opening file: {filename}')\n        return\n    \n    print(f'Total Records Read: {record_count}')\n\nif __name__ == '__main__':\n    read_indexed_file('data.db')",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.0010152836465084664,
      "code_bleu": 0.010577127886939876
    },
    {
      "cobol": "$SET NOBOUND\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. progn.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  x VALUE \"12345!\".\n           03  y PIC X OCCURS 5 TIMES.\n           03  z PIC X.\n       01  idx PIC 99 VALUE 6.\n\n       PROCEDURE DIVISION.\n           DISPLAY y (idx) WITH NO ADVANCING\n           .\n",
      "reference": "def main():\n    \"\"\"COBOL program translation\"\"\"\n    # Working storage variables\n    idx = 6\n\n    # Program logic\n    print(y (idx), end='')\n\nif __name__ == '__main__':\n    main()",
      "output": "def main():\n    print(y[idx], end='')\n\nif __name__ == '__main__':\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.1394411577840414,
      "code_bleu": 0.39129904508185737
    },
    {
      "cobol": "ID DIVISION.\n        PROGRAM-ID. ALLOC.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n        WORKING-STORAGE SECTION.\n        77  X   PIC  9(2) PACKED-DECIMAL.\n        77  NUM-ELEMENTS PIC 9(4) BINARY.\n        77  SIZE-NEEDED  PIC 9(4) BINARY.\n        77  old-size     pic 9(4) binary.\n        77  VPTR  POINTER.\n\n        LINKAGE       SECTION.\n\n        01  VARGRP.\n          02  OBJ     PIC 9(4) COMP.\n          02  TABGRP.\n            03  VARTAB OCCURS 1 TO UNBOUNDED DEPENDING ON OBJ.\n              04  T1      PIC 9(4).\n              04  T2      PIC X(8).\n              04  T3      PIC 9(4). *> changed from COMP because of output\n        01 BUFFER         PIC X(1000).\n\n       PROCEDURE DIVISION.\n\n      *>    DISPLAY 'Starting testcase ALLOC'\n\n           SET VPTR To NULL\n\n      *************************************************************\n      *  Allocate a table with 20 elements\n      *************************************************************\n           COMPUTE NUM-ELEMENTS = 20\n           PERFORM ALLOC-VARGRP\n\n      *************************************************************\n      *  Set some 'test' values to validate re-allocated table\n      *************************************************************\n           initialize vartab(12), vartab(17)\n           COMPUTE T1(12) = 9999\n           MOVE 'HI MOM' TO T2 (17)\n      *>   DISPLAY '  '\n           DISPLAY 'VARTAB(12) = \"' VARTAB(12) '\"'\n           DISPLAY 'VARTAB(17) = \"' VARTAB(17) '\"'\n      *>   DISPLAY '  '\n\n      *************************************************************\n      *  Need a bigger table! Allocate a larger one and copy data\n      *************************************************************\n           COMPUTE NUM-ELEMENTS = 30\n           PERFORM ALLOC-VARGRP\n\n      *************************************************************\n      *  Ensure that new table has correct data from original\n      *************************************************************\n           DISPLAY 'VARTAB(12) = \"' VARTAB(12) '\"'\n           DISPLAY 'VARTAB(17) = \"' VARTAB(17) '\"'\n\n           GOBACK.\n\n      *************************************************************\n      *  The first time allocate the original table.  If the table\n      *  has already been allocated, assume that we are allocating\n      *  a larger one and want to copy the data over to it\n      *************************************************************\n        ALLOC-VARGRP.\n\n           If VPTR = NULL Then      *> If first time, allocate the table\n             COMPUTE SIZE-NEEDED = LENGTH OF OBJ +\n                                 LENGTH OF VARTAB * NUM-ELEMENTS\n             display 'First allocation, using ' size-needed ' bytes.'\n             ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR\n\n             SET ADDRESS OF VARGRP TO VPTR\n             MOVE NUM-ELEMENTS TO OBJ\n             move SIZE-NEEDED  to old-size\n\n           Else                     *> If already have a table, doing re-size\n      *********************************************************************\n      * Re-size it!\n      * First, map BUFFER on current table\n      *********************************************************************\n\n             SET ADDRESS OF BUFFER TO VPTR\n\n      *********************************************************************\n      * Calculate new size from NUM-ElEMENTS\n      *********************************************************************\n             COMPUTE SIZE-NEEDED = LENGTH OF OBJ +\n                                   LENGTH OF VARTAB * NUM-ELEMENTS\n\n             display 'Re-allocation, using ' size-needed ' bytes.'\n      *>     ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED RETURNING VPTR\n             if size-needed < 2097152\n                ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED\n                                                loc 24\n                                                RETURNING VPTR\n             else\n                ALLOCATE SIZE-NEEDED CHARACTERS INITIALIZED\n                                                loc 31\n                                                RETURNING VPTR\n             end-if\n\n      *************************************************************\n      * Move data from data save area to new larger table\n      *************************************************************\n             SET ADDRESS OF VARGRP TO VPTR\n             MOVE NUM-ELEMENTS TO OBJ\n             MOVE BUFFER(1:old-size) TO VARGRP\n             move SIZE-NEEDED  to old-size\n      *************************************************************\n      * Free the original table\n      ************************************************************\n             SET VPTR TO ADDRESS OF BUFFER\n             FREE VPTR\n             .\n",
      "reference": "from decimal import Decimal, ROUND_HALF_UP\nimport math\n\ndef compute_examples():\n    \"\"\"COBOL COMPUTE statement equivalents with proper decimal handling\"\"\"\n\n    # Basic arithmetic with COBOL-style rounding\n    def compute(expression, decimals=2):\n        \"\"\"COMPUTE equivalent with ROUNDED\"\"\"\n        result = Decimal(str(expression))\n        if decimals >= 0:\n            quantize_str = '0.' + '0' * decimals if decimals > 0 else '0'\n            result = result.quantize(Decimal(quantize_str), rounding=ROUND_HALF_UP)\n        return result\n\n    # COMPUTE with multiple operations\n    a = Decimal('100.00')\n    b = Decimal('3')\n    c = Decimal('2.5')\n\n    # COMPUTE result = a / b\n    result1 = compute(a / b, 2)\n    print(f\"100 / 3 ROUNDED: {result1}\")\n\n    # COMPUTE result = a * b + c\n    result2 = compute(a * b + c, 2)\n    print(f\"100 * 3 + 2.5: {result2}\")\n\n    # COMPUTE with exponentiation (** in COBOL)\n    result3 = compute(Decimal('2') ** Decimal('10'), 0)\n    print(f\"2 ** 10: {result3}\")\n\n    # COMPUTE percentage\n    total = Decimal('1500.00')\n    part = Decimal('375.00')\n    pct = compute((part / total) * 100, 2)\n    print(f\"Percentage: {pct}%\")\n\n    # ON SIZE ERROR handling\n    def compute_with_size_check(expression, max_digits=9, decimals=2):\n        \"\"\"COMPUTE with ON SIZE ERROR equivalent\"\"\"\n        try:\n            result = compute(expression, decimals)\n            # Check if result exceeds max size\n            int_part = abs(int(result))\n            if len(str(int_part)) > max_digits:\n                raise OverflowError(\"Size error\")\n            return result, False  # result, size_error\n        except (OverflowError, ZeroDivisionError):\n            return Decimal('0'), True  # result, size_error\n\n    result, error = compute_with_size_check(Decimal('999999999') * 10, max_digits=9)\n    print(f\"Size error test: result={result}, error={error}\")\n\n    # Division with remainder\n    dividend = Decimal('17')\n    divisor = Decimal('5')\n    quotient = int(dividend // divisor)\n    remainder = dividend % divisor\n    print(f\"17 / 5: quotient={quotient}, remainder={remainder}\")\n\nif __name__ == '__main__':\n    compute_examples()",
      "output": "from decimal import Decimal, ROUND_HALF_UP\nimport math\n\ndef compute_examples():\n    \"\"\"COBOL COMPUTE statement equivalents with proper decimal handling\"\"\"\n\n    # Basic arithmetic with COBOL-style rounding\n    def compute(expression, decimals=2):\n        \"\"\"COMPUTE equivalent with ROUNDED\"\"\"\n        result = Decimal(str(expression))\n        if decimals >= 0:\n            quantize_str = '0.' + '0' * decimals if decimals > 0 else '0'\n            result = result.quantize(Decimal(quantize_str), rounding=ROUND_HALF_UP)\n        return result\n\n    # COMPUTE with multiple operations\n    a = Decimal('100.00')\n    b = Decimal('3')\n    c = Decimal('2.5')\n\n    # COMPUTE result = a / b\n    result1 = compute(a / b, 2)\n    print(f\"100 / 3 ROUNDED: {result1}\")\n\n    # COMPUTE result = a * b + c\n    result2 = compute(a * b + c, 2)\n    print(f\"100 * 3 + 2.5: {result2}\")\n\n    # COMPUTE with exponentiation (** in COBOL)\n    result3 = compute(Decimal('2') ** Decimal('10'), 0)\n    print(f\"2 ** 10: {result3}\")\n\n    # COMPUTE percentage\n    total = Decimal('1500.00')\n    part = Decimal('375.00')\n    pct = compute((part / total) * 100, 2)\n    print(f\"Percentage: {pct}%\")\n\n    # ON SIZE ERROR handling\n    def compute_with_size_check(expression, max_digits=9, decimals=2):\n        \"\"\"COMPUTE with ON SIZE ERROR equivalent\"\"\"\n        try:\n            result = compute(expression, decimals)\n            # Check if result exceeds max size\n            int_part = abs(int(result))\n            if len(str(int_part)) > max_digits:\n                raise OverflowError(\"Size error\")\n            return result, False  # result, size_error\n        except (OverflowError, ZeroDivisionError):\n            return Decimal('0'), True  # result, size_error\n\n    result, error = compute_with_size_check(Decimal('999999999') * 10, max_digits=9)\n    print(f\"Size error test: result={result}, error={error}\")\n\n    # Division with remainder\n    dividend = Decimal('17')\n    divisor = Decimal('5')\n    quotient = int(dividend // divisor)\n    remainder = dividend % divisor\n    print(f\"17 / 5: quotient={quotient}, remainder={remainder}\")\n\nif __name__ == '__main__':\n    compute_examples()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 1.0,
      "code_bleu": 1.0
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01  TEST-FLD     PIC S9(09)V9(02).\n       PROCEDURE        DIVISION.\n           MOVE FUNCTION INTEGER-OF-DAY ( 2000269 )\n             TO TEST-FLD.\n           IF TEST-FLD NOT = 000146000\n              DISPLAY TEST-FLD\n              END-DISPLAY\n           END-IF.\n           STOP RUN.\n",
      "reference": "def cobol_functions_example():\n    \"\"\"Demonstrates COBOL intrinsic function equivalents\"\"\"\n    import math\n    from datetime import datetime, date\n\n    # Numeric functions\n    value = -42.7\n    abs_val = abs(value)                    # FUNCTION ABS\n    integer_val = int(value)                # FUNCTION INTEGER\n    integer_part = int(abs(value))          # FUNCTION INTEGER-PART\n\n    # Math functions\n    x = 2.5\n    sqrt_val = math.sqrt(x)                 # FUNCTION SQRT\n    log_val = math.log(x)                   # FUNCTION LOG\n    log10_val = math.log10(x)               # FUNCTION LOG10\n    exp_val = math.exp(x)                   # FUNCTION EXP\n\n    # Trigonometric\n    angle = 0.5\n    sin_val = math.sin(angle)               # FUNCTION SIN\n    cos_val = math.cos(angle)               # FUNCTION COS\n    tan_val = math.tan(angle)               # FUNCTION TAN\n    asin_val = math.asin(angle)             # FUNCTION ASIN\n\n    # String functions\n    text = \"  Hello World  \"\n    trimmed = text.strip()                  # FUNCTION TRIM\n    upper = text.upper()                    # FUNCTION UPPER-CASE\n    lower = text.lower()                    # FUNCTION LOWER-CASE\n    reversed_text = text[::-1]              # FUNCTION REVERSE\n    length = len(text)                      # FUNCTION LENGTH\n\n    # Date/Time functions\n    now = datetime.now()\n    current_date = now.strftime(\"%Y%m%d\")   # FUNCTION CURRENT-DATE\n    day_of_week = now.isoweekday()          # FUNCTION DAY-OF-WEEK (1=Mon)\n\n    # Statistical functions\n    numbers = [10, 20, 30, 40, 50]\n    max_val = max(numbers)                  # FUNCTION MAX\n    min_val = min(numbers)                  # FUNCTION MIN\n    sum_val = sum(numbers)                  # FUNCTION SUM\n    mean_val = sum(numbers) / len(numbers)  # FUNCTION MEAN\n\n    # ORD and CHAR\n    char_code = ord('A')                    # FUNCTION ORD\n    char_val = chr(65)                      # FUNCTION CHAR\n\n    return {\n        'abs': abs_val,\n        'sqrt': sqrt_val,\n        'trim': trimmed,\n        'upper': upper,\n        'max': max_val,\n        'mean': mean_val\n    }\n\nif __name__ == '__main__':\n    result = cobol_functions_example()\n    for k, v in result.items():\n        print(f\"{k}: {v}\")",
      "output": "def cobol_program():\n    \"\"\"Basic COBOL program structure equivalent\"\"\"\n\n    # WORKING-STORAGE SECTION\n    ws_counter = 0\n    ws_total = 0\n    ws_status = '00'\n    ws_eof = False\n\n    # PROCEDURE DIVISION\n\n    # Initialization\n    ws_counter = 0\n    ws_total = 0\n\n    # Main processing loop\n    while not ws_eof:\n        # Read/process data\n        ws_counter += 1\n        ws_total += ws_counter\n\n        # Check termination condition\n        if ws_counter >= 10:\n            ws_eof = True\n\n    # Termination\n    print(f\"Records processed: {ws_counter}\")\n    print(f\"Total: {ws_total}\")\n    print(f\"Status: {ws_status}\")\n\n    return ws_status\n\nif __name__ == '__main__':\n    result = cobol_program()\n    print(f\"Program ended with status: {result}\")",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.011838211572683124,
      "code_bleu": 0.022134903356079573
    },
    {
      "cobol": "CONTROL\t\tDIVISION.\n       DEFAULT\t\tSECTION.\n       IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01 VAR PIC X(2) VALUE \"OK\".\n       PROCEDURE        DIVISION.\n           DISPLAY VAR NO ADVANCING\n           END-DISPLAY.\n           STOP RUN.\n",
      "reference": "def main():\n    print(VAR, end='')\n\nif __name__ == '__main__':\n    main()",
      "output": "def main():\n    print(var, end='')\n\nif __name__ == '__main__':\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.6606328636027614,
      "code_bleu": 1.0
    },
    {
      "cobol": "IDENTIFICATION       DIVISION.\n       PROGRAM-ID.          prog.\n\n       DATA                 DIVISION.\n       WORKING-STORAGE      SECTION.\n       01  a.\n           03  b            PIC X(3) VALUE SPACES.\n           03  c            PIC X(3) VALUE SPACES.\n\n       01  p.\n           03  q            PIC 9(3) VALUE ZERO.\n           03  r            PIC X(3) VALUE \"abc\".\n\n       01  x.\n           03  y.\n               05  z        PIC X VALUE SPACE.\n\n       01  out              PIC X(100).\n\n       PROCEDURE            DIVISION.\n           XML GENERATE out FROM a SUPPRESS WHEN SPACES\n           IF out <> '<a/>'\n               DISPLAY 'Test 1 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM a SUPPRESS b WHEN SPACES\n           IF out <> '<a><c> </c></a>'\n               DISPLAY 'Test 2 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM a SUPPRESS EVERY NONNUMERIC WHEN SPACES\n           IF out <> '<a/>'\n               DISPLAY 'Test 3 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM p\n               WITH ATTRIBUTES\n               SUPPRESS EVERY ATTRIBUTE WHEN ZERO\n           IF out <> '<p r=\"abc\"/>'\n               DISPLAY 'Test 4 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM a\n               SUPPRESS c WHEN LOW-VALUES, c WHEN SPACES,\n                    c WHEN LOW-VALUES,\n                    EVERY ELEMENT WHEN SPACES\n           IF out <> '<a><c> </c></a>'\n               DISPLAY 'Test 5 failed: ' out\n           END-IF\n\n           MOVE HIGH-VALUES TO b\n           MOVE LOW-VALUES TO c\n           XML GENERATE out FROM a\n               SUPPRESS EVERY ELEMENT WHEN HIGH-VALUES OR LOW-VALUES\n                   OR ZEROES OR SPACES\n           IF out <> '<a/>'\n               DISPLAY 'Test 6 failed: ' out\n           END-IF\n\n           XML GENERATE out FROM x SUPPRESS z WHEN SPACE\n           IF out <> '<x/>'\n               DISPLAY 'Test 7 failed: ' out\n           END-IF\n           .\n",
      "reference": "class ReportWriter:\n    \"\"\"COBOL Report Writer (RD) equivalent\"\"\"\n\n    def __init__(self, filename, page_limit=60, heading_lines=3):\n        self.filename = filename\n        self.page_limit = page_limit\n        self.heading_lines = heading_lines\n        self.line_counter = 0\n        self.page_counter = 0\n        self.file = None\n        self.controls = {}\n        self.totals = {}\n\n    def initiate(self):\n        \"\"\"INITIATE report-name\"\"\"\n        self.file = open(self.filename, 'w')\n        self.line_counter = 0\n        self.page_counter = 0\n        self.totals = {}\n\n    def terminate(self):\n        \"\"\"TERMINATE report-name\"\"\"\n        self._write_final_totals()\n        self.file.close()\n\n    def generate(self, line_type, data=None, control_field=None):\n        \"\"\"GENERATE detail-line or summary-line\"\"\"\n\n        # Check for control break\n        if control_field:\n            if control_field in self.controls:\n                if self.controls[control_field] != data.get(control_field):\n                    self._write_control_footing(control_field)\n                    self._write_control_heading(control_field, data)\n            else:\n                self._write_control_heading(control_field, data)\n            self.controls[control_field] = data.get(control_field)\n\n        # Check for page break\n        if self.line_counter >= self.page_limit:\n            self._new_page()\n\n        # Write the line\n        if line_type == 'DETAIL':\n            self._write_detail(data)\n        elif line_type == 'HEADING':\n            self._write_heading(data)\n\n        self.line_counter += 1\n\n    def _new_page(self):\n        self.page_counter += 1\n        self.file.write('\\f')  # Form feed\n        self.line_counter = 0\n        self._write_page_heading()\n\n    def _write_page_heading(self):\n        self.file.write(f\"{'=' * 70}\\n\")\n        self.file.write(f\"Page {self.page_counter:4d}\\n\")\n        self.file.write(f\"{'=' * 70}\\n\")\n        self.line_counter += self.heading_lines\n\n    def _write_heading(self, data):\n        self.file.write(f\"{data.get('title', 'REPORT')}\\n\")\n\n    def _write_detail(self, data):\n        line = ' | '.join(str(v) for v in data.values())\n        self.file.write(f\"{line}\\n\")\n\n        # Accumulate totals\n        for key, value in data.items():\n            if isinstance(value, (int, float)):\n                self.totals[key] = self.totals.get(key, 0) + value\n\n    def _write_control_heading(self, field, data):\n        self.file.write(f\"\\n--- {field}: {data.get(field)} ---\\n\")\n\n    def _write_control_footing(self, field):\n        self.file.write(f\"--- End of {field} ---\\n\\n\")\n\n    def _write_final_totals(self):\n        self.file.write(\"\\n\" + \"=\" * 40 + \"\\n\")\n        self.file.write(\"FINAL TOTALS:\\n\")\n        for key, value in self.totals.items():\n            self.file.write(f\"  {key}: {value}\\n\")\n\n# Example usage\nif __name__ == '__main__':\n    report = ReportWriter('sales_report.txt', page_limit=20)\n    report.initiate()\n\n    # Sample data\n    sales_data = [\n        {'region': 'EAST', 'product': 'Widget', 'amount': 1500},\n        {'region': 'EAST', 'product': 'Gadget', 'amount': 2300},\n        {'region': 'WEST', 'product': 'Widget', 'amount': 1800},\n        {'region': 'WEST', 'product': 'Gadget', 'amount': 2100},\n    ]\n\n    for record in sales_data:\n        report.generate('DETAIL', record, control_field='region')\n\n    report.terminate()\n    print(\"Report generated: sales_report.txt\")",
      "output": "def cobol_program():\n    \"\"\"Basic COBOL program structure equivalent\"\"\"\n\n    # WORKING-STORAGE SECTION\n    ws_counter = 0\n    ws_total = 0\n    ws_status = '00'\n    ws_eof = False\n\n    # PROCEDURE DIVISION\n\n    # Initialization\n    ws_counter = 0\n    ws_total = 0\n\n    # Main processing loop\n    while not ws_eof:\n        # Read/process data\n        ws_counter += 1\n        ws_total += ws_counter\n\n        # Check termination condition\n        if ws_counter >= 10:\n            ws_eof = True\n\n    # Termination\n    print(f\"Records processed: {ws_counter}\")\n    print(f\"Total: {ws_total}\")\n    print(f\"Status: {ws_status}\")\n\n    return ws_status\n\nif __name__ == '__main__':\n    result = cobol_program()\n    print(f\"Program ended with status: {result}\")",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.006317106271437353,
      "code_bleu": 0.0015508976418801687
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE SECTION.\n       77  window-handle USAGE HANDLE OF WINDOW.\n       77  lb-row        PIC X(10).\n       77  lb-color      PIC 9(05) VALUE 8192.\n       77  lb-num-lines  PIC 9(02) VALUE 20.\n       77  lb-num-rows   PIC 9(02) VALUE 11.\n       77  window-lines  PIC 9(02) VALUE 22.\n       77  window-rows   PIC 9(02) VALUE 13.\n       77  selection-idx PIC S9(02).\n       SCREEN SECTION.\n       01 lb-screen.\n           03 lb-frm LIST-BOX 3-D\n      *             FIXME: the following should be possible in any order\n                    UNSORTED\n                    EXCEPTION-VALUE = 13\n                    COLOR lb-color\n                    CLINE 1 CCOL 1\n                    LINES = lb-num-lines\n                    SIZE  IS lb-num-rows\n      *             VALUE lb-row  raises error as no identifer according\n      *                           to cobol2002, but here it is fine\n                    .\n       PROCEDURE DIVISION.\n       MAIN.\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 1'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 2'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 3'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 4'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 5'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 6'\n           MODIFY lb-frm ITEM-TO-ADD = 'Row 7'\n           DISPLAY FLOATING WINDOW\n               LINE 5 COL 5\n               LINES window-lines\n               SIZE  window-rows\n               BOXED\n               COLOR lb-color\n               HANDLE IS window-handle\n           END-DISPLAY\n           DISPLAY lb-screen\n           ACCEPT  lb-screen\n           IF lb-row = SPACES\n              INQUIRE lb-frm SELECTION-INDEX IN selection-idx\n              IF selection-idx > ZERO\n                 MODIFY  lb-frm QUERY-INDEX = selection-idx\n                 INQUIRE lb-frm ITEM-VALUE IN lb-row\n              END-IF\n           END-IF\n           CLOSE WINDOW window-handle\n           DISPLAY \"chosen row value was '\" lb-row \"'\"\n           ACCEPT OMITTED\n      *\n           STOP RUN.\n",
      "reference": "def main():\n    \"\"\"COBOL program translation for prog (GnuCOBOL #326)\"\"\"\n    # This COBOL program has complex features\n    # Original COBOL performs: output display, conditional logic, screen/GUI handling\n    print(\"COBOL program executed\")\n\nif __name__ == '__main__':\n    main()",
      "output": "class ReportWriter:\n    \"\"\"COBOL Report Writer (RD) equivalent\"\"\"\n\n    def __init__(self, filename, page_limit=60, heading_lines=3):\n        self.filename = filename\n        self.page_limit = page_limit\n        self.heading_lines = heading_lines\n        self.line_counter = 0\n        self.page_counter = 0\n        self.file = None\n        self.controls = {}\n        self.totals = {}\n\n    def initiate(self):\n        \"\"\"INITIATE report-name\"\"\"\n        self.file = open(self.filename, 'w')\n        self.line_counter = 0\n        self.page_counter = 0\n        self.totals = {}\n\n    def terminate(self):\n        \"\"\"TERMINATE report-name\"\"\"\n        self._write_final_totals()\n        self.file.close()\n\n    def generate(self, line_type, data=None, control_field=None):\n        \"\"\"GENERATE detail-line or summary-line\"\"\"\n\n        # Check for control break\n        if control_field:\n            if control_field in self.controls:\n                if self.controls[control_field] != data.get(control_field):\n                    self._write_control_footing(control_field)\n                    self._write_control_heading(control_field, data)\n            else:\n                self._write_control_heading(control_field, data)\n            self.controls[control_field] = data.get(control_field)\n\n        # Check for page break\n        if self.line_counter >= self.page_limit:\n            self._new_page()\n\n        # Write the line\n        if line_type == 'DETAIL':\n            self._write_detail(data)\n        elif line_type == 'HEADING':\n            self._write_heading(data)\n\n        self.line_counter += 1\n\n    def _new_page(self):\n        self.page_counter += 1\n        self.file.write('\\f')  # Form feed\n        self.line_counter = 0\n        self._write_page_heading()\n\n    def _write_page_heading(self):\n        self.file.write(f\"{'=' * 70}\\n\")\n        self.file.write(f\"Page {self.page_counter:4d}\\n\")\n        self.file.write(f\"{'=' * 70}\\n\")\n        self.line_counter += self.heading_lines\n\n    def _write_heading(self, data):\n        self.file.write(f\"{data.get('title', 'REPORT')}\\n\")\n\n    def _write_detail(self, data):\n        line = ' | '.join(str(v) for v in data.values())\n        self.file.write(f\"{line}\\n\")\n\n        # Accumulate totals\n        for key, value in data.items():\n            if isinstance(value, (int, float)):\n                self.totals[key] = self.totals.get(key, 0) + value\n\n    def _write_control_heading(self, field, data):\n        self.file.write(f\"\\n--- {field}: {data.get(field)} ---\\n\")\n\n    def _write_control_footing(self, field):\n        self.file.write(f\"--- End of {field} ---\\n\\n\")\n\n    def _write_final_totals(self):\n        self.file.write(\"\\n\" + \"=\" * 40 + \"\\n\")\n        self.file.write(\"FINAL TOTALS:\\n\")\n        for key, value in self.totals.items():\n            self.file.write(f\"  {key}: {value}\\n\")\n\n# Example usage\nif __name__ == '__main__':\n    report = ReportWriter('sales_report.txt', page_limit=20)\n    report.initiate()\n\n    # Sample data\n    sales_data = [\n        {'region': 'EAST', 'product': 'Widget', 'amount': 1500},\n        {'region': 'EAST', 'product': 'Gadget', 'amount': 2300},\n        {'region': 'WEST', 'product': 'Widget', 'amount': 1800},\n        {'region': 'WEST', 'product': 'Gadget', 'amount': 2100},\n    ]\n\n    for record in sales_data:\n        report.generate('DETAIL', record, control_field='region')\n\n    report.terminate()\n    print(\"Report generated: sales_report.txt\")",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.010096199301515197,
      "code_bleu": 0.020214971440619695
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       PROCEDURE        DIVISION.\n           DISPLAY \"OK\"-\n            \"OK\"\n             NO ADVANCING\n           END-DISPLAY\n           STOP RUN.\n",
      "reference": "def main():\n    print(\"OK\", \"OK\", end='')\n    print('')\n\nif __name__ == '__main__':\n    main()",
      "output": "def main():\n    print(\"OK\", end=\"\")\n    print(\"OK\", end=\"\")\n\nif __name__ == '__main__':\n    main()",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.46924700641056,
      "code_bleu": 0.7019373395364499
    },
    {
      "cobol": "IDENTIFICATION   DIVISION.\n       PROGRAM-ID.      prog.\n       DATA             DIVISION.\n       WORKING-STORAGE  SECTION.\n       01  X            PIC X(2) VALUE \"OK\".\n       PROCEDURE        DIVISION.\n           CALL \"C$TOLOWER\" USING X BY VALUE 2\n           END-CALL.\n           IF X NOT = \"ok\"\n              DISPLAY X NO ADVANCING\n              END-DISPLAY\n           END-IF.\n           STOP RUN.\n",
      "reference": "def main_program():\n    \"\"\"COBOL CALL statement equivalents\"\"\"\n\n    # Simple CALL\n    print(\"Calling subprogram...\")\n    result = subprogram_1(\"input_value\")\n    print(f\"Returned: {result}\")\n\n    # CALL with BY REFERENCE (modifiable)\n    data = {'value': 100, 'status': 'A'}\n    subprogram_by_reference(data)\n    print(f\"After BY REFERENCE call: {data}\")\n\n    # CALL with BY CONTENT (copy, not modifiable)\n    original = \"original\"\n    subprogram_by_content(original)\n    print(f\"After BY CONTENT call: {original}\")  # Unchanged\n\n    # CALL with BY VALUE\n    num = 42\n    result = subprogram_by_value(num)\n    print(f\"BY VALUE result: {result}\")\n\n    # CALL with RETURNING\n    return_value = subprogram_with_return()\n    print(f\"RETURNING value: {return_value}\")\n\n    # CALL with ON EXCEPTION (error handling)\n    try:\n        call_with_exception(\"nonexistent_program\")\n    except ModuleNotFoundError:\n        print(\"ON EXCEPTION: Program not found\")\n\n    # CANCEL - unload program (in Python, just del reference)\n    print(\"Program completed\")\n\ndef subprogram_1(param):\n    \"\"\"Basic subprogram\"\"\"\n    return f\"processed_{param}\"\n\ndef subprogram_by_reference(data_dict):\n    \"\"\"BY REFERENCE - modifies the passed data\"\"\"\n    data_dict['value'] += 50\n    data_dict['status'] = 'M'\n\ndef subprogram_by_content(data):\n    \"\"\"BY CONTENT - receives a copy\"\"\"\n    data = \"modified\"  # Only modifies local copy\n    return data\n\ndef subprogram_by_value(num):\n    \"\"\"BY VALUE - receives value\"\"\"\n    return num * 2\n\ndef subprogram_with_return():\n    \"\"\"RETURNING clause equivalent\"\"\"\n    return 999\n\ndef call_with_exception(prog_name):\n    \"\"\"ON EXCEPTION equivalent\"\"\"\n    # In real COBOL, this would try to load the program\n    raise ModuleNotFoundError(f\"Program {prog_name} not found\")\n\nif __name__ == '__main__':\n    main_program()",
      "output": "def cobol_program():\n    \"\"\"Basic COBOL program structure equivalent\"\"\"\n\n    # WORKING-STORAGE SECTION\n    ws_counter = 0\n    ws_total = 0\n    ws_status = '00'\n    ws_eof = False\n\n    # PROCEDURE DIVISION\n\n    # Initialization\n    ws_counter = 0\n    ws_total = 0\n\n    # Main processing loop\n    while not ws_eof:\n        # Read/process data\n        ws_counter += 1\n        ws_total += ws_counter\n\n        # Check termination condition\n        if ws_counter >= 10:\n            ws_eof = True\n\n    # Termination\n    print(f\"Records processed: {ws_counter}\")\n    print(f\"Total: {ws_total}\")\n    print(f\"Status: {ws_status}\")\n\n    return ws_status\n\nif __name__ == '__main__':\n    result = cobol_program()\n    print(f\"Program ended with status: {result}\")",
      "valid_syntax": true,
      "syntax_error": null,
      "bleu": 0.014240407936639917,
      "code_bleu": 0.05225638108724163
    }
  ],
  "summary": {
    "base": {
      "valid_syntax_pct": 90.0,
      "avg_bleu": 0.0283152159261232,
      "avg_code_bleu": 0.08137899175525452
    },
    "finetuned": {
      "valid_syntax_pct": 100.0,
      "avg_bleu": 0.3312828236526147,
      "avg_code_bleu": 0.4199970666031068
    }
  }
}